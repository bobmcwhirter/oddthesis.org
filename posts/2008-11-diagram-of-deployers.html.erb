---
title: "Diagram of Deployers"
author: Bob McWhirter
layout: post
---
<p>Thanks to help from Ales, I've been able to really clean up and simplify the JBoss Rails deployers for Microcontainer.&nbsp; When you use JBoss Microcontainer, you can easily break down your tasks into small, bite-sized chunks.&nbsp; Because of that, we now have 7 deployers, but each only has a handful of lines.</p>
<p>First, the picture, then we'll walk through it.</p>
<p><img src="/system/assets/ruby-deployers.png" alt="Deployers" width="408" height="640" /></p>
<p>Of the many deployment stages MC walks through, the JBoss Rails deployment of web apps and schedulers requires only 3: <strong>Parse</strong>, <strong>Describe</strong> and <strong>Real</strong>.</p>
<h3>Parsing</h3>
<p>The <strong>RailsRootReferenceParsingDeployer</strong> is responsible for handling any file matching <strong>*-rails.yml</strong> in your appserver's <strong>deploy/</strong> directory.&nbsp; This is the small YAML file that points to your <strong>RAILS_ROOT</strong> on disk, injects the <strong>RAILS_ENV</strong> you wish to deploy in, and sets up the web context root.&nbsp; This deployer handles the reference file, and emits a <strong>RailsMetaData</strong> object.</p>
<p>Once the <strong>RailsMetaData</strong> object is available, the <strong>RailsVersionDeployer</strong> is fired.&nbsp; Since we require Rails itself to be in your app's <strong>vendor/</strong> directory, we can dig around inside there to find Rails's <strong>version.rb,</strong> and figure out if we're running a version of at least 2.2.&nbsp; If we're running 2.1 (non-threadsafe), we just have to change our deployment strategy for some bits.&nbsp; When this deployer fires and reads the <strong>version.rb</strong>, it emits a <strong>RailsVersionMetaData</strong> object, which simply embodies the version number of Rails used by this app.</p>
<p>Meanwhile, unrelated to anything Rails-specific, the <strong>YamlScheduleParsingDeployer</strong> is on the lookout for any meta-data file named <strong>jboss-scheduler.yml</strong>.&nbsp; The scheduler file handles cron tasks inside your app's code. Nothing about the scheduler is inherently Rails-centric, but it is Ruby-centric.&nbsp; I anticipate being able to use the same deployer to handle schedulers in Merb, or Camping, or any other ruby framework.</p>
<p>The output from parsing a <strong>jboss-scheduler.yml</strong> is a <strong>ScheduleMetaData</strong> object.</p>
<h3>Describing</h3>
<p>While the above-mentioned scheduler stuff is framework-agnostic, it still needs some help from whichever framework it's deployed in.&nbsp; The <strong>ScheduleMetaData</strong> contains information such as the name of the Ruby class to instantiate to perform the scheduled job.&nbsp; It needs some additional information, such as <em>where to look for these classes</em>.&nbsp; It's also helpful if the scheduler knows the thread-safeness of the framework it's associated it.</p>
<p>So the <strong>RailsScheduleDescribeDeployer</strong> is hanging around, looking at metadata flow by.&nbsp; If there's a <strong>RailsMetaData</strong>, and a <strong>RailsVersionMetaData</strong>, and a <strong>ScheduleMetaData</strong> object available in this deloyment, then it'll step in.</p>
<p>By convention, JBoss Rails assumes that scheduled task classes are in the files under <strong>$RAILS_ROOT/app/scheduler/</strong>.&nbsp; We also know if Rails is threadsafe or not based upon the version being used.</p>
<p>So the <strong>RailsScheduleDescribeDeployer</strong> looks at the Rails-specific metadata flowing in, and adjusts the existing Rails-agnostic <strong>ScheduleMetaData</strong> by adding <strong>$RAILS_ROOT/app/scheduler/</strong> to the Ruby load path and setting the thread-safety flag.</p>
<p><strong>Note</strong>: This may be better suited as a Post-Parsing stage deployer.&nbsp; I'm not sure yet.</p>
<h3>Real Deployment</h3>
<p>The real stage is where the rubber meets the road.&nbsp; All of this MetaData that's floating around gets converted into instances of <strong>BeanMetaData</strong>.&nbsp; Microcontainer's own <strong>BeanMetaDataDeployer</strong> consumes those, and will instantiate and <strong>start()</strong> our actual POJOs.&nbsp; The <strong>BeanMetaData</strong> simply describes your POJO's Java class name, constructor arguments, properties to set or inject with other POJOs, annotations to apply, and runtime methods (such as <strong>start()</strong> and <strong>stop()</strong>) that should be called.</p>
<p>The <strong>RailsRuntimeFactoryDeployer</strong> sees the <strong>RailsMetaData</strong>, and creates a <strong>BeanMetaData</strong> describing a factory to produce initialized JRuby runtimes for your Rails app.&nbsp; It assigns a predictable name so that other POJOs can find it if they need it.&nbsp; Other frameworks will be able to deploy factories that are capable of initializing JRuby runtimes for their environments.</p>
<p>The <strong>RailsWebDeployer</strong> sees the <strong>RailsMetaData</strong>, and creates a <strong>BeanMetaData</strong> describing an object that can setup and remove a Tomcat web context for your Rails app.</p>
<p>The <strong>ScheduleDeployer</strong> creates a <strong>BeanMetaData</strong> describing object that can add and remove scheduled tasks from the Quartz scheduler embedded in AS5.&nbsp; This deployer creates <strong>BeanMetaDatas</strong> that inject the runtime factory described by the <strong>RailsRuntimeFactoryDeployer</strong>.</p>
<p>All of these <strong>BeanMetaData</strong> instances then float on by, are grabbed by MC's own <strong>BeanMetaDataDeployer</strong>.&nbsp; My classes are instantiated, properties are set, <strong>start()</strong> is called, and we find ourselves deployed. My deployers also add object-instance JMX annotations to the BeanMetaData objects.&nbsp; This causes my POJOs to get registered in the MBeanServer and to appear in the JMX console.&nbsp; Pretty slick.</p>
<h3>Conclusion</h3>
<p>Overall, I really like Microcontainer's deployment framework.&nbsp; I don't always completely understand it, and I routinely overlook classes that will do 80% of the work for me.&nbsp;&nbsp; It's been a long road, but breaking 1 deployer into 7 has simplified everything, honestly.&nbsp; The chunks are smaller, and more importantly, they are reusable.&nbsp; I did not want to have to write scheduler logic for each Ruby framework I attack.&nbsp; MC's multi-stage metadata-driven deployment process really helps.</p>
